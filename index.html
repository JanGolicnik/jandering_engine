<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>k k k kys</title>
    <style>
      canvas {
        background-color: black;
      }
    </style>

    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Roboto&family=Roboto+Mono&display=swap" rel="stylesheet">

    <style>

      :root {
        --darkest-color: #252c4d;
        --mid-color: #434b76;
        --light-color: #81689D;
        --main-color: #fff1fa;
        --main-color-alpha: #fff1fab6;
      }

      html, body {
          height: 100%;
          width: auto;
          overflow: hidden;
          font-family: 'Roboto', sans-serif;
          text-rendering: geometricPrecision;
      }

      #wgsltoy_shadercode{
        max-width: 100%;
        min-width: 100%;
        min-height: 95vh;
        max-height: 95vh;
        word-wrap: unset;
        padding: 1em;
        background-color: var(--main-color);
        border-radius: 5px;
        font-size: 15px;
        font-family: 'Roboto', sans-serif;
        font-family: 'Roboto Mono', monospace;
      }

      body{
        background: var(--darkest-color);
        display: flex;
      }

      div#left_area {
        min-width:40%;
      }

      div#right_area{
        width: 100%;
        display:flex;
        flex-direction: column;
        align-items: center;
        padding: 20px;
      }

      div#jandering-engine-canvas-body{
        background-color: var(--main-color);
        justify-self: center;
        box-shadow: 0px 0px 10px var(--main-color-alpha);
        margin:0;
        height: 500px;
        padding:3px;
        border-radius: 5px;
      }

      #refresh_button{
        all:unset;
        padding: 10px;
        border-radius: 50%;
        cursor: pointer;
        margin: 10px;
      }

      #wgsltoy_error_box{
        width: 90%;
        color: red;
        font-size: small;
      }

    </style>
  </head>

  <body>
    <input id="wgsltoy_updateshader" hidden="true" value="true"></input>
    <div id="left_area">
      <textarea autocorrect="off" autocapitalize="off" spellcheck="false" id="wgsltoy_shadercode">
@fragment
fn fs_main(in: VertexOutput) -> @location(0) vec4<f32>{

    var uv = in.uv * 2.0 - 1.0;
    uv.x *= uResolution.res.x / uResolution.res.y;

    let origin = vec3<f32>(0.0, 0.0, 0.0);
    let direction = normalize(vec3<f32>(uv, 1.0));

    var t = 0.0;

    var i = 0;
    for(; i < 80; i++){
        var position: vec3<f32> = origin + direction * t;
        let percent = f32(i) / 80.0;
        let cos_sin_time = cos(sin(uTime.elapsed * 0.32));
        let rotated_xy = position.xy * rot2D(t * cos_sin_time * percent) * cos_sin_time * cos_sin_time;
        position.x = rotated_xy.x;
        position.y = rotated_xy.y;
        position *= (f32(i) / 80.0);
        
        let distance = map(position);

        t += distance;

        if(distance < 0.001 || t > 100.0){ break; }
    }
 
    let color = pallete(t * 0.02 + (f32(i) / 80.0) * 0.2 );

    return vec4<f32>(color, 1.0);
}

fn dist_octahedron(position: vec3<f32>, s: f32) -> f32 {
    let pos = abs(position);
    return (pos.x + pos.y + pos.z - s) * 0.57735027;
}

fn dist_sphere(position: vec3<f32>, radius: f32) -> f32 {
    return length(position) - radius;
}

fn dist_box(position: vec3<f32>, sides: vec3<f32>) -> f32{
    let q = abs(position) - sides;
    return length(max(q, vec3<f32>(0.0))) + min(max(q.x, max(q.y,q.z)), 0.0);
}

fn smin(a: f32, b: f32, k: f32) -> f32 {
    let h = max( k - abs(a - b), 0.0) / k;
    return min( a, b) - h * h * h * k * (1.0 / 6.0);
}

fn pallete(t: f32) -> vec3<f32> {
    let a = vec3<f32>(0.5);
    let b = vec3<f32>(0.5);
    let c = vec3<f32>(1.0);
    let d = vec3<f32>(0.263, 0.416, 0.557);

    return a + b * cos( 6.28318 * ( c * t + d ) );
}

fn modulo_euclidean(a: f32, b: f32) -> f32 {
	var m = a % b;
	if (m < 0.0) {
		if (b < 0.0) {
			m -= b;
		} else {
			m += b;
		}
	}
	return m;
}

fn rot2D(angle: f32) -> mat2x2<f32>{
    let s = sin(angle);
    let c = cos(angle);
    return mat2x2(c, -s, s, c);
}

fn map(position: vec3<f32>) -> f32 {
    var p = position;
    p.z += uTime.elapsed * 0.9;

    p.x = fract(p.x) - 0.5;
    p.y = fract(p.y) - 0.5;
    p.z = modulo_euclidean(p.z, 0.25) - 0.125;

    let box = dist_octahedron(p, 0.13);

    return box;
}
      </textarea>
    </div>
    

    <div id="right_area">
      <div id="jandering-engine-canvas-body"></div>
      <button id="refresh_button">
        <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" stroke="none" fill="var(--main-color)"><path d="M13.5 2c-5.621 0-10.211 4.443-10.475 10h-3.025l5 6.625 5-6.625h-2.975c.257-3.351 3.06-6 6.475-6 3.584 0 6.5 2.916 6.5 6.5s-2.916 6.5-6.5 6.5c-1.863 0-3.542-.793-4.728-2.053l-2.427 3.216c1.877 1.754 4.389 2.837 7.155 2.837 5.79 0 10.5-4.71 10.5-10.5s-4.71-10.5-10.5-10.5z"/></svg>
      </button>
      <p id="wgsltoy_error_box"></p>
    </div>

    <script type="module" defer>
      import initWasm, { run } from "./pkg/wgsltoy.js";
      
      initWasm().then(()=>{
        run();
      });

      document.getElementById("refresh_button").addEventListener('click', send_shader);
    </script>

    <script defer>
      function send_shader(){
        let input = document.getElementById("wgsltoy_updateshader");
        input.value = "true";
      }

      setTimeout(send_shader, 10);
    </script>

  </body>
</html>
